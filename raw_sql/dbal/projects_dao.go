package dbal

// Code generated by a tool. DO NOT EDIT.
// Additional custom methods can be implemented in a separate file like <this_file>_ex.go.
// https://sqldalmaker.sourceforge.net/

import (
	"context"
	"sdm_demo_todolist/raw_sql/dbal/dto"
)

type ProjectsDao struct {
	ds DataStore
}

// (C)RUD: projects
// Generated/AI values are passed to DTO/model.

func (dao *ProjectsDao) CreateProject(ctx context.Context, p *dto.Project) error {
	sql := `insert into projects (p_name) values (?)`
	row, err := dao.ds.Insert(ctx, sql, "p_id", p.PName)
	if err == nil {
		err = SetRes(&p.PId, row)
	}
	return err
}

// C(R)UD: projects

func (dao *ProjectsDao) ReadProject(ctx context.Context, pId int64) (*dto.Project, error) {
	sql := `select * from projects where p_id=?`
	row, err := dao.ds.QueryRow(ctx, sql, pId)
	if err != nil {
		return nil, err
	}
	res := dto.Project{}
	errMap := make(map[string]int)
	SetInt64(&res.PId, row, "p_id", errMap)
	SetString(&res.PName, row, "p_name", errMap)
	err = ErrMapToErr(errMap)
	return &res, err
}

// CR(U)D: projects

func (dao *ProjectsDao) UpdateProject(ctx context.Context, p *dto.Project) (rowsAffected int64, err error) {
	sql := `update projects set p_name=? where p_id=?`
	rowsAffected, err = dao.ds.Exec(ctx, sql, p.PName, p.PId)
	return
}

// CRU(D): projects

func (dao *ProjectsDao) DeleteProject(ctx context.Context, p *dto.Project) (rowsAffected int64, err error) {
	sql := `delete from projects where p_id=?`
	rowsAffected, err = dao.ds.Exec(ctx, sql, p.PId)
	return
}

func (dao *ProjectsDao) GetProjectList(ctx context.Context) (res []*dto.Project, err error) {
	sql := `select p.*, 
		(select count(*) from tasks where p_id=p.p_id) as p_tasks_count 
		from projects p 
		order by p.p_id`
	errMap := make(map[string]int)
	_onRow := func(row map[string]interface{}) {
		obj := dto.Project{}
		SetInt64(&obj.PId, row, "p_id", errMap)
		SetString(&obj.PName, row, "p_name", errMap)
		SetInt64(&obj.PTasksCount, row, "p_tasks_count", errMap)
		res = append(res, &obj)
	}
	err = dao.ds.QueryAllRows(ctx, sql, _onRow)
	if err == nil {
		err = ErrMapToErr(errMap)
	}
	return
}

func (dao *ProjectsDao) GetProjectIds(ctx context.Context) (res []int64, err error) {
	sql := `select p.*, 
		(select count(*) from tasks where p_id=p.p_id) as p_tasks_count 
		from projects p 
		order by p.p_id`
	errMap := make(map[string]int)
	onRow := func(val interface{}) {
		var data int64
		SetScalarValue(&data, val, errMap)
		res = append(res, data)
	}
	err = dao.ds.QueryAll(ctx, sql, onRow)
	if err == nil {
		err = ErrMapToErr(errMap)
	}
	return
}

func (dao *ProjectsDao) GetProjectId(ctx context.Context) (int64, error) {
	sql := `select p.*, 
		(select count(*) from tasks where p_id=p.p_id) as p_tasks_count 
		from projects p 
		order by p.p_id`
	r, err := dao.ds.Query(ctx, sql)
	var res int64
	if err == nil {
		err = SetRes(&res, r)
	}
	return res, err
}
